package Inner_Class;

/*
 * 如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类
 * 分类：成员内部类和局部内部类（包含匿名内部类）
 * 成员内部类：
 *   ·格式：修饰符 class 外部类名称{
 *               修饰符 class 内部类名称{
 *                   //...
 *               }
 *               //...
 *          }
 *   ·注：内访问外无限制，外访问内，需要内部类对象
 *   ·使用：  1.间接：在外部类的方法中使用内部类，然后main仅调用外部类方法
 *           2.直接：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称()
 *   ·如果内部类变量名与外部类重名，则使用：外部类名称.this.外部类成员变量名
 * 局部内部类：如果一个类定义在方法内部，那么这就是一个局部内部类，其只能被该方法使用，该方法之外无法使用
 *   ·格式：修饰符 class 外部类名称{
 *           修饰符 返回值类型 外部方法名称（参数列表）{
 *               class 局部内部类名称{
 *                   //...
 *               }
 *               //...
 *            }
 *            //...
 *          }
 *   ·final问题：如果局部内部类希望访问所在方法的局部变量，那么这个局部变量需要是有效final的（不可变）且如果变量事实不变可省略final。
 *       原因：new的对象存在于堆内存，局部变量与方法一同存在于栈内存，方法结束运行出栈使得局部变量消失，但new的对象会一直存在，直到垃圾回收。
 *           一言以蔽之，生命周期不同。
 *   ·匿名内部类：如果接口的实现类或父类的子类只需要使用唯一一次，那么就可以省略该类的定义，使用匿名内部类
 *       #定义格式：接口名称 对象名 = new 接口名称（）{
 *                       //覆盖重写所有抽象方法
 *                 }
 *               new表示创建对象这个动作，接口名称表示匿名内部类需要实现哪个接口，{...}是具体内容
 *       #注：
 *           1.匿名内部类在创建对象时只能使用唯一一次
 *           2.匿名对象在调用方法只能调用唯一一次
 *           3.匿名内部类省略了实现类、子类名称，匿名对象省略了对象名称
 * 定义类的权限修饰符规则：
 * 1.外部类：public、（default）
 * 2.成员内部类：public、protected、（default）、private
 * 3.局部内部类：什么都不写
 * 类作为成员变量（public ClassName className）
 * 接口可作为成员变量、参数、返回值
 *
 * */
public class Definition {
    public static void main(String[] args) {
        //间接
        Demo01 demo01 = new Demo01("Susan");
        demo01.methodDemo01Outer();

        //直接
        Demo01.Demo01Inner demo01Inner = new Demo01("Susan").new Demo01Inner();
        demo01Inner.methodDemo01Inner();

        demo01Inner.method02Demo01Inner();

        Demo02 demo02 = new Demo02();
        demo02.method();
    }
}
